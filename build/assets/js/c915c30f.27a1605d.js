"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[737],{963:(e,r,n)=>{n.d(r,{A:()=>o});n(6540);var a=n(4164);const t={callout:"callout_jYHE",info:"info_IOty",tip:"tip_s2nh",caution:"caution_w7Js",danger:"danger_zfsw",icon:"icon_Ghiv",content:"content_JMk4"};var i=n(4848);function o({type:e,children:r}){const n=function(e){switch(e){case"info":default:return"\u2139\ufe0f";case"tip":return"\ud83d\udca1";case"caution":return"\u26a0\ufe0f";case"danger":return"\u274c"}}(e),o=(0,a.A)("callout",t.callout,t[e]);return(0,i.jsxs)("div",{className:o,children:[(0,i.jsx)("div",{className:t.icon,children:n}),(0,i.jsx)("div",{className:t.content,children:r})]})}},4245:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"module-3-isaac/chapter-14-isaac-ros","title":"Chapter 14 - Isaac ROS","description":"Learning Objectives","source":"@site/docs/module-3-isaac/chapter-14-isaac-ros.mdx","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/chapter-14-isaac-ros","permalink":"/humanoid-robotics/docs/module-3-isaac/chapter-14-isaac-ros","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Muhammad Uzair","lastUpdatedAt":1765045729000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Chapter 14 - Isaac ROS"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 13 - Synthetic Data","permalink":"/humanoid-robotics/docs/module-3-isaac/chapter-13-synthetic-data"},"next":{"title":"Chapter 15 - Nav2","permalink":"/humanoid-robotics/docs/module-3-isaac/chapter-15-nav2"}}');var t=n(4848),i=n(8453),o=n(963);const s={sidebar_position:4,title:"Chapter 14 - Isaac ROS"},l="Chapter 14: Isaac ROS Integration",c={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Content with Code Examples",id:"content-with-code-examples",level:2},{value:"Mermaid Diagrams",id:"mermaid-diagrams",level:2},{value:"Callouts",id:"callouts",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function m(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"chapter-14-isaac-ros-integration",children:"Chapter 14: Isaac ROS Integration"})}),"\n",(0,t.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(r.p,{children:"After completing this chapter, you should be able to:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Integrate Isaac Sim with ROS/ROS2 for robot control"}),"\n",(0,t.jsx)(r.li,{children:"Use Isaac ROS packages for perception and navigation"}),"\n",(0,t.jsx)(r.li,{children:"Implement real-to-sim and sim-to-real workflows"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"content-with-code-examples",children:"Content with Code Examples"}),"\n",(0,t.jsx)(r.p,{children:"Isaac ROS provides a bridge between NVIDIA's Isaac platform and the Robot Operating System, enabling developers to leverage both ecosystems."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:'\x3c!-- Example launch file for Isaac ROS bridge --\x3e\r\n<launch>\r\n  \x3c!-- Start Isaac Sim --\x3e\r\n  <node name="isaac_sim" pkg="isaac_sim" type="isaac_sim_node" output="screen">\r\n    <param name="config_file" value="$(find my_robot_isaac)/config/robot_config.yaml"/>\r\n  </node>\r\n  \r\n  \x3c!-- Start ROS bridge --\x3e\r\n  <node name="ros_bridge" pkg="omni.isaac.ros_bridge" type="ros_bridge_node" output="screen">\r\n    <param name="publish_frequency" value="30"/>\r\n  </node>\r\n  \r\n  \x3c!-- Start robot controller --\x3e\r\n  <node name="robot_controller" pkg="my_robot_control" type="controller_node" output="screen">\r\n    <param name="control_rate" value="100"/>\r\n  </node>\r\n</launch>\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-python",children:'# Example Isaac ROS node\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, CameraInfo\r\nfrom geometry_msgs.msg import Twist\r\nfrom cv_bridge import CvBridge\r\nimport numpy as np\r\n\r\nclass IsaacROSController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_ros_controller\')\r\n        \r\n        # Initialize CvBridge for image conversion\r\n        self.bridge = CvBridge()\r\n        \r\n        # Create subscribers for Isaac Sim sensors\r\n        self.image_sub = self.create_subscription(\r\n            Image,\r\n            \'/front_camera/image_raw\',\r\n            self.image_callback,\r\n            10)\r\n        \r\n        self.camera_info_sub = self.create_subscription(\r\n            CameraInfo,\r\n            \'/front_camera/camera_info\',\r\n            self.camera_info_callback,\r\n            10)\r\n        \r\n        # Create publisher for robot control\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        \r\n        # Timer for control loop\r\n        self.timer = self.create_timer(0.1, self.control_loop)\r\n        \r\n        # Internal state\r\n        self.latest_image = None\r\n        self.camera_info = None\r\n        self.obstacle_detected = False\r\n\r\n    def image_callback(self, msg: Image):\r\n        """Process images from Isaac Sim"""\r\n        try:\r\n            # Convert ROS Image to OpenCV\r\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding=\'bgr8\')\r\n            \r\n            # Simple obstacle detection (in a real application, this would be more sophisticated)\r\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\r\n            height, width = gray.shape\r\n            \r\n            # Check the center region for obstacles (using intensity as a proxy)\r\n            center_region = gray[int(height*0.4):int(height*0.6), int(width*0.4):int(width*0.6)]\r\n            avg_intensity = np.mean(center_region)\r\n            \r\n            self.obstacle_detected = avg_intensity < 50  # Adjust threshold as needed\r\n            self.latest_image = cv_image\r\n            \r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error processing image: {e}\')\r\n\r\n    def camera_info_callback(self, msg: CameraInfo):\r\n        """Store camera calibration parameters"""\r\n        self.camera_info = msg\r\n\r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        msg = Twist()\r\n        \r\n        if self.obstacle_detected:\r\n            # Stop if obstacle detected\r\n            msg.linear.x = 0.0\r\n            msg.angular.z = 0.5  # Turn to avoid obstacle\r\n        else:\r\n            # Move forward otherwise\r\n            msg.linear.x = 0.5\r\n            msg.angular.z = 0.0\r\n        \r\n        self.cmd_vel_pub.publish(msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = IsaacROSController()\r\n    \r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(r.h2,{id:"mermaid-diagrams",children:"Mermaid Diagrams"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-mermaid",children:"graph TD;\r\n    A[Real Robot] --\x3e B[Isaac ROS Bridge]\r\n    C[Isaac Sim] --\x3e B\r\n    B --\x3e D[ROS/ROS2 Ecosystem]\r\n    D --\x3e E[Navigation Stack]\r\n    D --\x3e F[Perception Nodes]\r\n    D --\x3e G[Control Nodes]\r\n    E --\x3e H[Path Planner]\r\n    F --\x3e I[Object Detector]\r\n    G --\x3e J[Controller]\n"})}),"\n",(0,t.jsx)(r.h2,{id:"callouts",children:"Callouts"}),"\n",(0,t.jsx)(o.A,{type:"info",children:(0,t.jsx)(r.p,{children:"Isaac ROS packages provide GPU-accelerated perception algorithms that can significantly outperform CPU-only implementations in ROS."})}),"\n",(0,t.jsx)(o.A,{type:"tip",children:(0,t.jsx)(r.p,{children:"Use Isaac Sim to develop and test ROS nodes before deploying to real hardware, reducing development time and risk."})}),"\n",(0,t.jsx)(o.A,{type:"caution",children:(0,t.jsx)(r.p,{children:"Performance characteristics in simulation may differ from real hardware. Always validate on real robots before deployment."})}),"\n",(0,t.jsx)(r.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"Set up Isaac Sim with ROS bridge for a robot model"}),"\n",(0,t.jsx)(r.li,{children:"Implement a simple navigation stack using Isaac ROS packages"}),"\n",(0,t.jsx)(r.li,{children:"Test robot control in simulation before real-world deployment"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Isaac ROS enables integration between Isaac platform and ROS/ROS2"}),"\n",(0,t.jsx)(r.li,{children:"GPU-accelerated perception algorithms improve performance"}),"\n",(0,t.jsx)(r.li,{children:"Simulation helps develop and test ROS nodes safely"}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>s});var a=n(6540);const t={},i=a.createContext(t);function o(e){const r=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(i.Provider,{value:r},e.children)}}}]);