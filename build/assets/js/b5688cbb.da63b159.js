"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[801],{963:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var r=t(4164);const o={callout:"callout_jYHE",info:"info_IOty",tip:"tip_s2nh",caution:"caution_w7Js",danger:"danger_zfsw",icon:"icon_Ghiv",content:"content_JMk4"};var a=t(4848);function s({type:e,children:n}){const t=function(e){switch(e){case"info":default:return"\u2139\ufe0f";case"tip":return"\ud83d\udca1";case"caution":return"\u26a0\ufe0f";case"danger":return"\u274c"}}(e),s=(0,r.A)("callout",o.callout,o[e]);return(0,a.jsxs)("div",{className:s,children:[(0,a.jsx)("div",{className:o.icon,children:t}),(0,a.jsx)("div",{className:o.content,children:n})]})}},4365:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"module-4-vla/chapter-20-capstone-project","title":"Chapter 20 - Capstone Project","description":"Learning Objectives","source":"@site/docs/module-4-vla/chapter-20-capstone-project.mdx","sourceDirName":"module-4-vla","slug":"/module-4-vla/chapter-20-capstone-project","permalink":"/humanoid-robotics/docs/module-4-vla/chapter-20-capstone-project","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Muhammad Uzair","lastUpdatedAt":1765045729000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Chapter 20 - Capstone Project"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 19 - Multi-Modal Interaction","permalink":"/humanoid-robotics/docs/module-4-vla/chapter-19-multi-modal-interaction"}}');var o=t(4848),a=t(8453),s=t(963);const i={sidebar_position:5,title:"Chapter 20 - Capstone Project"},l="Chapter 20: Capstone Project - Integrating Physical AI Systems",c={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Content with Code Examples",id:"content-with-code-examples",level:2},{value:"Mermaid Diagrams",id:"mermaid-diagrams",level:2},{value:"Callouts",id:"callouts",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-20-capstone-project---integrating-physical-ai-systems",children:"Chapter 20: Capstone Project - Integrating Physical AI Systems"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"After completing this chapter, you should be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Design and implement a complete Physical AI system integrating multiple technologies"}),"\n",(0,o.jsx)(n.li,{children:"Apply all concepts learned throughout the book in a cohesive project"}),"\n",(0,o.jsx)(n.li,{children:"Evaluate and optimize the performance of integrated systems"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"content-with-code-examples",children:"Content with Code Examples"}),"\n",(0,o.jsx)(n.p,{children:"The capstone project brings together all the concepts learned in this book to create a comprehensive Physical AI system. We'll design and implement a robot that can understand natural language commands, navigate environments, perceive objects, and execute complex tasks."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String, Bool\r\nfrom geometry_msgs.msg import Twist, PoseStamped\r\nfrom sensor_msgs.msg import Image, LaserScan\r\nfrom cv_bridge import CvBridge\r\nimport json\r\nimport numpy as np\r\nimport time\r\nfrom typing import Dict, List, Optional\r\n\r\nclass CapstoneRobotController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'capstone_robot_controller\')\r\n        \r\n        # Initialize components\r\n        self.bridge = CvBridge()\r\n        self.current_state = "idle"  # idle, navigating, manipulating, etc.\r\n        self.task_queue = []\r\n        self.robot_capabilities = {\r\n            \'navigation\': True,\r\n            \'manipulation\': False,  # Assuming a non-manipulator robot for this example\r\n            \'perception\': True,\r\n            \'communication\': True\r\n        }\r\n        \r\n        # Robot state\r\n        self.position = (0.0, 0.0, 0.0)  # x, y, theta\r\n        self.battery_level = 1.0\r\n        self.objects_detected = {}\r\n        self.goal_position = None\r\n        \r\n        # Publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.goal_pub = self.create_publisher(PoseStamped, \'/goal_pose\', 10)\r\n        self.speech_pub = self.create_publisher(String, \'/tts_input\', 10)\r\n        self.status_pub = self.create_publisher(String, \'/robot_status\', 10)\r\n        \r\n        # Subscribers\r\n        self.voice_cmd_sub = self.create_subscription(\r\n            String,\r\n            \'/voice_command\',\r\n            self.voice_command_callback,\r\n            10\r\n        )\r\n        \r\n        self.image_sub = self.create_subscription(\r\n            Image,\r\n            \'/camera/rgb/image_raw\',\r\n            self.image_callback,\r\n            10\r\n        )\r\n        \r\n        self.lidar_sub = self.create_subscription(\r\n            LaserScan,\r\n            \'/scan\',\r\n            self.lidar_callback,\r\n            10\r\n        )\r\n        \r\n        # Timer for state machine\r\n        self.state_timer = self.create_timer(0.1, self.state_machine)\r\n        \r\n        # Navigation feedback\r\n        self.nav_complete_sub = self.create_subscription(\r\n            Bool,\r\n            \'/navigation_complete\',\r\n            self.navigation_complete_callback,\r\n            10\r\n        )\r\n        \r\n        self.get_logger().info("Capstone Robot Controller initialized")\r\n        self.say("Capstone robot system initialized. Ready for commands.")\r\n\r\n    def voice_command_callback(self, msg: String):\r\n        """Process high-level voice commands"""\r\n        command = msg.data.lower()\r\n        self.get_logger().info(f"Received command: {command}")\r\n        \r\n        # Simple command parsing (would be more sophisticated in practice)\r\n        if "go to" in command or "navigate to" in command:\r\n            # Extract target location\r\n            if "kitchen" in command:\r\n                self.add_navigation_task((3.0, 2.0, 0.0), "kitchen")\r\n            elif "living room" in command:\r\n                self.add_navigation_task((1.0, -1.0, 1.57), "living room")\r\n            elif "bedroom" in command:\r\n                self.add_navigation_task((-2.0, 1.0, 3.14), "bedroom")\r\n            else:\r\n                self.say("I don\'t know where that location is. Please specify kitchen, living room, or bedroom.")\r\n                \r\n        elif "find" in command or "look for" in command:\r\n            # Find objects\r\n            if "ball" in command or "object" in command:\r\n                self.add_perception_task("ball")\r\n            elif "person" in command:\r\n                self.add_perception_task("person")\r\n                \r\n        elif "stop" in command:\r\n            self.stop_robot()\r\n            self.say("Robot stopped")\r\n            \r\n        elif "status" in command or "report" in command:\r\n            self.report_status()\r\n            \r\n        else:\r\n            self.say(f"I don\'t understand the command: {command}")\r\n\r\n    def add_navigation_task(self, target_pos: tuple, location_name: str):\r\n        """Add a navigation task to the queue"""\r\n        task = {\r\n            \'type\': \'navigation\',\r\n            \'target\': target_pos,\r\n            \'location_name\': location_name,\r\n            \'priority\': 1\r\n        }\r\n        \r\n        self.task_queue.append(task)\r\n        self.say(f"Navigation task added: going to {location_name}")\r\n\r\n    def add_perception_task(self, target_object: str):\r\n        """Add a perception task to the queue"""\r\n        task = {\r\n            \'type\': \'perception\',\r\n            \'target\': target_object,\r\n            \'priority\': 2  # Higher priority than navigation\r\n        }\r\n        \r\n        self.task_queue.insert(0, task)  # Insert at beginning for higher priority\r\n        self.say(f"Perception task added: looking for {target_object}")\r\n\r\n    def image_callback(self, msg: Image):\r\n        """Process image data for object detection"""\r\n        try:\r\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding=\'bgr8\')\r\n            \r\n            # Detect objects in the image\r\n            detected_objects = self.detect_objects_in_image(cv_image)\r\n            \r\n            # Update robot\'s knowledge\r\n            for obj in detected_objects:\r\n                self.objects_detected[obj[\'name\']] = {\r\n                    \'position\': obj[\'position\'],\r\n                    \'confidence\': obj[\'confidence\'],\r\n                    \'timestamp\': time.time()\r\n                }\r\n                \r\n        except Exception as e:\r\n            self.get_logger().error(f"Error processing image: {e}")\r\n\r\n    def lidar_callback(self, msg: LaserScan):\r\n        """Process LIDAR data for navigation and obstacle avoidance"""\r\n        # Update robot position based on odometry would happen here\r\n        # For this example, we just store the LIDAR data\r\n        \r\n        # Check for obstacles in the immediate vicinity\r\n        min_distance = min([r for r in msg.ranges if r != float(\'inf\')], default=float(\'inf\'))\r\n        \r\n        if min_distance < 0.5:  # Less than 0.5m is too close\r\n            # Emergency stop if obstacle too close\r\n            self.stop_robot()\r\n            self.say("Obstacle detected. Stopping robot.")\r\n\r\n    def navigation_complete_callback(self, msg: Bool):\r\n        """Handle navigation completion"""\r\n        if msg.data and self.current_state == "navigating":\r\n            self.current_state = "idle"\r\n            self.say("Navigation task completed.")\r\n\r\n    def detect_objects_in_image(self, image):\r\n        """Detect objects in the image using simple color-based detection"""\r\n        # Convert to HSV for color-based segmentation\r\n        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\r\n        \r\n        # Define color ranges for common objects\r\n        color_ranges = {\r\n            \'red_ball\': ([0, 50, 50], [10, 255, 255]),\r\n            \'blue_object\': ([100, 50, 50], [130, 255, 255]),\r\n            \'green_object\': ([40, 50, 50], [80, 255, 255])\r\n        }\r\n        \r\n        detected_objects = []\r\n        \r\n        for obj_name, (lower, upper) in color_ranges.items():\r\n            # Create mask for color range\r\n            mask = cv2.inRange(hsv, np.array(lower), np.array(upper))\r\n            \r\n            # Find contours\r\n            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n            \r\n            # Filter contours by area\r\n            for cnt in contours:\r\n                area = cv2.contourArea(cnt)\r\n                if area > 1000:  # Only consider objects larger than 1000 pixels\r\n                    # Get bounding box\r\n                    x, y, w, h = cv2.boundingRect(cnt)\r\n                    \r\n                    # Calculate approximate position relative to image center\r\n                    center_x = x + w/2\r\n                    center_y = y + h/2\r\n                    img_center_x = image.shape[1] / 2\r\n                    \r\n                    # Determine rough direction (left/right/center)\r\n                    if center_x < img_center_x - 50:\r\n                        direction = "left"\r\n                    elif center_x > img_center_x + 50:\r\n                        direction = "right"\r\n                    else:\r\n                        direction = "center"\r\n                        \r\n                    detected_objects.append({\r\n                        \'name\': obj_name,\r\n                        \'position\': direction,\r\n                        \'confidence\': min(area / 5000, 1.0)  # Normalize confidence\r\n                    })\r\n        \r\n        return detected_objects\r\n\r\n    def state_machine(self):\r\n        """Main state machine for robot behavior"""\r\n        if self.current_state == "idle" and self.task_queue:\r\n            # Execute next task\r\n            task = self.task_queue.pop(0)\r\n            \r\n            if task[\'type\'] == \'navigation\':\r\n                self.current_state = "navigating"\r\n                self.navigate_to_position(task[\'target\'], task[\'location_name\'])\r\n            elif task[\'type\'] == \'perception\':\r\n                self.current_state = "perceiving"\r\n                self.perceive_object(task[\'target\'])\r\n                \r\n        # Update status periodically\r\n        self.publish_status()\r\n\r\n    def navigate_to_position(self, target_pos: tuple, location_name: str):\r\n        """Navigate to a specific position"""\r\n        self.get_logger().info(f"Navigating to {location_name} at {target_pos}")\r\n        \r\n        goal_msg = PoseStamped()\r\n        goal_msg.header.stamp = self.get_clock().now().to_msg()\r\n        goal_msg.header.frame_id = \'map\'\r\n        goal_msg.pose.position.x = float(target_pos[0])\r\n        goal_msg.pose.position.y = float(target_pos[1])\r\n        goal_msg.pose.position.z = 0.0\r\n        \r\n        # Convert theta to quaternion\r\n        theta = target_pos[2]\r\n        goal_msg.pose.orientation.z = np.sin(theta / 2.0)\r\n        goal_msg.pose.orientation.w = np.cos(theta / 2.0)\r\n        \r\n        self.goal_pub.publish(goal_msg)\r\n        self.say(f"Navigating to {location_name}")\r\n\r\n    def perceive_object(self, target_object: str):\r\n        """Look for a specific object using camera and image processing"""\r\n        self.get_logger().info(f"Looking for {target_object}")\r\n        \r\n        # In this implementation, we\'ll check what was detected in the last image\r\n        if target_object in [obj.split(\'_\')[0] for obj in self.objects_detected.keys()]:\r\n            # Object found\r\n            obj = [k for k in self.objects_detected.keys() if target_object in k][0]\r\n            position = self.objects_detected[obj][\'position\']\r\n            confidence = self.objects_detected[obj][\'confidence\']\r\n            \r\n            self.say(f"Found {obj} in the {position} area with confidence {confidence:.2f}")\r\n        else:\r\n            # Object not found\r\n            self.say(f"Could not find {target_object} in the current view")\r\n            \r\n        self.current_state = "idle"  # Return to idle after perception task\r\n\r\n    def report_status(self):\r\n        """Report current robot status"""\r\n        status = {\r\n            \'state\': self.current_state,\r\n            \'position\': self.position,\r\n            \'battery\': self.battery_level,\r\n            \'detected_objects\': list(self.objects_detected.keys()),\r\n            \'tasks_pending\': len(self.task_queue)\r\n        }\r\n        \r\n        status_msg = String()\r\n        status_msg.data = json.dumps(status)\r\n        self.status_pub.publish(status_msg)\r\n        \r\n        self.say(f"Status: I am {self.current_state}, at position {self.position[:2]}, "\r\n                 f"battery at {self.battery_level*100:.1f}%, "\r\n                 f"detected {len(self.objects_detected)} objects, "\r\n                 f"{len(self.task_queue)} tasks pending")\r\n\r\n    def stop_robot(self):\r\n        """Stop the robot"""\r\n        cmd = Twist()\r\n        cmd.linear.x = 0.0\r\n        cmd.angular.z = 0.0\r\n        self.cmd_vel_pub.publish(cmd)\r\n        self.current_state = "idle"\r\n\r\n    def say(self, text: str):\r\n        """Publish text for TTS"""\r\n        msg = String()\r\n        msg.data = text\r\n        self.speech_pub.publish(msg)\r\n        self.get_logger().info(f"Robot says: {text}")\r\n\r\n    def publish_status(self):\r\n        """Publish robot status periodically"""\r\n        status = {\r\n            \'state\': self.current_state,\r\n            \'timestamp\': time.time()\r\n        }\r\n        \r\n        status_msg = String()\r\n        status_msg.data = json.dumps(status)\r\n        self.status_pub.publish(status_msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = CapstoneRobotController()\r\n    \r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"mermaid-diagrams",children:"Mermaid Diagrams"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-mermaid",children:"graph TD;\r\n    A[User Command] --\x3e B[Natural Language Processing]\r\n    B --\x3e C[Task Planning]\r\n    C --\x3e D[Multi-Modal Perception]\r\n    D --\x3e E[State Estimation]\r\n    E --\x3e F[Action Selection]\r\n    F --\x3e G[Navigation & Control]\r\n    G --\x3e H[Execution Monitoring]\r\n    H --\x3e I{Task Complete?}\r\n    I --\x3e|No| J[Replanning]\r\n    I --\x3e|Yes| K[Report Result]\r\n    J --\x3e C\r\n    K --\x3e L[Next Task]\r\n    L --\x3e C\r\n    M[Sensor Data] --\x3e D\r\n    N[Knowledge Base] --\x3e C\r\n    O[Robot State] --\x3e E\r\n    P[Environment Model] --\x3e G\n"})}),"\n",(0,o.jsx)(n.h2,{id:"callouts",children:"Callouts"}),"\n",(0,o.jsx)(s.A,{type:"info",children:(0,o.jsx)(n.p,{children:"The capstone project demonstrates how to integrate all the technologies covered in this book: navigation, perception, natural language processing, and multi-modal interaction."})}),"\n",(0,o.jsx)(s.A,{type:"tip",children:(0,o.jsx)(n.p,{children:"When implementing complex integrated systems, use state machines or behavior trees to manage the different operational modes and transitions."})}),"\n",(0,o.jsx)(s.A,{type:"caution",children:(0,o.jsx)(n.p,{children:"Integration is often the most challenging part of robotics projects. Plan for debugging time and implement good logging and visualization tools."})}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Extend the capstone project to include actual manipulation capabilities"}),"\n",(0,o.jsx)(n.li,{children:"Integrate LLMs for high-level task planning in the capstone system"}),"\n",(0,o.jsx)(n.li,{children:"Implement a learning component that improves performance over time"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Integration of multiple technologies creates powerful Physical AI systems"}),"\n",(0,o.jsx)(n.li,{children:"State management and task planning are crucial for complex behaviors"}),"\n",(0,o.jsx)(n.li,{children:"Real-world deployment requires robustness to handle unexpected situations"}),"\n",(0,o.jsx)(n.li,{children:"Continuous evaluation and improvement are essential for practical systems"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Congratulations on completing the Physical AI & Humanoid Robotics book! You've now learned:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"ROS 2 fundamentals and advanced concepts"}),"\n",(0,o.jsx)(n.li,{children:"Simulation environments and digital twins"}),"\n",(0,o.jsx)(n.li,{children:"Isaac platform for AI-powered robotics"}),"\n",(0,o.jsx)(n.li,{children:"Vision-language-action models and multimodal interaction"}),"\n",(0,o.jsx)(n.li,{children:"How to integrate all these technologies in practical systems"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You're now equipped to develop sophisticated Physical AI systems that bridge the gap between artificial intelligence and the physical world. The next step is to apply these concepts to your own robotics projects!"})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(6540);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);